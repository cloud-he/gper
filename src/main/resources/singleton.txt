单例模式常见写法及优缺点:
1.饿汉式
    // 它是在类加载的时候就立即初始化，并且创建单例对象

    //优点：没有加任何的锁、执行效率比较高，
    //在用户体验上来说，比懒汉式更好

    //缺点：类加载的时候就初始化，不管你用还是不用，我都占着空间
    //浪费了内存，有可能占着茅坑不拉屎

    //绝对线程安全，在线程还没出现以前就是实例化了，不可能存在访问安全问题
2.懒汉式
  a.常规懒汉式单例
      //在外部需要使用的时候才进行实例化
      //优点:不提前占用内存,不存在浪费内存
      //缺点:方法上不加synchronized 线程不安全,加上,性能受损
   b.DoubleCheck懒汉式
      //在外部需要使用的时候才进行实例化
      //性能上优于常规性
    c.静态内部类懒汉式
      //这种形式兼顾饿汉式的内存浪费，也兼顾synchronized性能问题
      //完美地屏蔽了这两个缺点
      //史上最牛B的单例模式的实现方式
3.注册式单例
    a.容器
    //Spring中的做法，就是用这种注册式单例
    b.枚举
    //常量中去使用，常量就是用来大家都能够共用的.
    //通常在通用API中使用

4.线程式
    //通过ThreadLocal来作为容器


破坏单例模式的方式:
1.反序列化
   //反序列化时导致单例破坏

   //序列化就是说把内存中的状态通过转换成字节码的形式
   //从而转换一个IO流，写入到其他地方(可以是磁盘、网络IO)
   //内存中状态给永久保存下来了

   //反序列化
   //讲已经持久化的字节码内容，转换为IO流
   //通过IO流的读取，进而将读取的内容转换为Java对象
   //在转换过程中会重新创建对象new

   //解决方案: 实现readResolve方法

2.反射实例化
   //通过反射拿到私有的构造方法
  Constructor c = clazz.getDeclaredConstructor(null);
  //强制访问，强吻，不愿意也要吻
  c.setAccessible(true);
  //暴力初始化
  Object o1 = c.newInstance();
 //解决方案: 构造方法中加入验证
        if(LazyHolder.LAZY != null){
             throw new RuntimeException("不允许创建多个实例");
         }


梳理静态内部类执行逻辑
1.加载外部类
2.外部类的构造方法
3.调用内部类静态方法时,先加载静态内部类
4.执行静态方法
load outer class...
==========分割线==========
load static inner class...
static inner method...